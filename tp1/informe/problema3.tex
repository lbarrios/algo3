% ------ headers globales y begin ---------------
\documentclass[11pt, a4paper, twoside]{article}
\usepackage{header_tp1}
\begin{document}{}
% -----------------------------------------------

\subsubsection{Descripción}

Este problema consiste en ubicar en un tablero la mayor cantidad de piezas
posibles siguiendo ciertas reglas.

\begin{itemize}   
	\item El tablero contiene $n \times m$ casilleros cuadrados, $n$ filas y $m$
	columnas.

	\item Piezas existentes: $1,...,n \times m$. (Cantidad total de 
	piezas: $n \times m$).

	\item Una pieza es cuadrada y puede tener de $1$ a $4$ colores distintos. 
	A cada lado $(sup, izq, der, inf)$ le corresponde un color. 

	\item Las piezas no se pueden rotar.

	\item Colores posibles: $1,...,c$ ($c$ entero positivo).

	\item 2 piezas pueden ubicarse en casilleros adyacentes sólo si sus lados 
	adyacentes tienen el mismo color. Podría ocurrir que no sea posible 
	llenar completamente el tablero con las piezas existentes. 

	%\item El contenido final de una casilla podría ser $1,...,n \times m$, 
	%si se pudo colocar alguna ficha, o $0$ si quedara vacía.

	%\item Cantidad mínima de piezas que se pueden colocar en el tablero: 
	%$(n \times m)/ 2$. (Se intercalan las piezas en el tablero).

\end{itemize} 

El problema se deberá resolver utilizando la técnica de $Backtracking$
eligiendo algunas podas para mejorar los tiempos de ejecución del programa.

\centerbf{Ejemplos}

\begin{ejemplo}

  Para un tablero de $3\times 3$ y uno de $2\times 2$, suponiendo un caso  donde
  ninguna ficha puede colocarse adyacente a otra, una de las posibles  soluciones
  sería la siguiente:

  En el tablero de $3\times 3$ se podrían colocar las fichas $1,2,3,4$  y $5$, y
  en el de $2\times 2$, las fichas $1$ y $2$.

  \begin{center}
      \begin{minipage}{0.2\textwidth}
          \begin{tabular}{|c|c|c|}
              \hline
               $1$ & $0$ & $2$ \\
              \hline
               $0$ & $3$ & $0$  \\
              \hline 
               $4$ & $0$ & $5$ \\
              \hline
          \end{tabular}
      \end{minipage}
      \begin{minipage}{0.2\textwidth}
          \begin{tabular}{|c|c|}
              \hline
               $1$ & $0$ \\
              \hline
               $0$ & $2$ \\
              \hline
          \end{tabular}
      \end{minipage}
  \end{center}

\end{ejemplo}

\begin{ejemplo}

	Se tiene un tablero de $2\times 2$, los colores $1,2,3$ 
    y las piezas \textbf{1},\textbf{2},\textbf{3},\textbf{4} $:$

  \begin{center}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $1$     &       \\
            $3$  & \textbf{1} &   $2$ \\ 
                 & $2$     &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $3$     &       \\
            $2$  & \textbf{2} & $2$ \\ 
                 & $1$     &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $3$      &       \\
            $1$  & \textbf{2}  & $3$ \\ 
                 & $2$      &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $1$      &       \\
            $1$  & \textbf{4}  & $2$   \\ 
                 & $2$      &       \\
            \hline
        \end{tabular} 
    \end{minipage}
   \end{center}
   
  En este caso, la cantidad máxima de piezas que se pueden colocar en el tablero es $3$. Entonces las posibles soluciones serían:
  
  \begin{center}
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{tabular}{ | l | l |}
            \hline 
            \textbf{1}  & \textbf{2} \\ 
            \hline 
            $0$  & \textbf{4} \\ 
            \hline
        \end{tabular}  \\
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \begin{tabular}{ | l | l |}
            \hline 
            $0$     & \textbf{2} \\ 
            \hline 
            \textbf{3}  & \textbf{1} \\ 
            \hline
        \end{tabular} \\
    \end{minipage}
  \end{center}
\end{ejemplo}

\centerbf{Algoritmos de backtracking (ideas y análisis general)}

El objetivo del problema es diseñar un algoritmo utilizando la técnica de
\textbf{backtracking}. El algoritmo de \textbf{backtracking} se puede concebir
como una técnica recursiva de recorrido de grafos\footnote{Quizás la oración no
está expresada de la mejor forma; al decir ``se puede concebir como...'' se
quiere dar a entender que no se está dando la definición estricta de
backtracking, sino una \emph{interpretación}. Se dio por entendido el hecho de
que en su sentido más básico es ``una técnica de resolución de problemas'';
representando al ``universo de soluciones'' como un grafo, \textbf{y en el
contexto del párrafo}, creemos que la idea que se intenta exponer es válida.},
estableciendo un paralelismo entre <<el universo de soluciones>>, y los nodos de
un \textbf{grafo arbol n-ario}, en donde cada nodo representa una solución
posible, y $n$ representa la cantidad máxima de soluciones distintas que pueden
desprenderse a partir de realizar un cambio determinado en la solución anterior
(\emph{vecindad}). Además puede, según el caso, ser interpretado como un árbol
en donde cada nodo representa \textbf{una solución no necesariamente ``válida''}
(o ``bien formada''), y en donde sólamente \textbf{las hojas del árbol} son
\emph{soluciones correctamente formadas} (no necesariamente factibles).

Podemos separar también el tipo de problema en dos casos: los
\darkgreen{\textbf{problemas de decisión}}, para los que es necesario que la
solución cumpla \darkgreen{ciertas condiciones particulares} determinados por la
denominada \darkgreen{\textbf{función de selección}}, y los
\blue{\textbf{problemas de optimización}}, los cuales son derivados de los
anteriores, y en donde se desea obtener \blue{la \textbf{``mejor''}} de las
soluciones válidas\footnote{ Es decir, las que cumplan con el criterio de
selección. Tener en cuenta que esto último no implica necesariamente la
existencia de funciones inválidas, sino que puede darse el caso en que el
criterio de selección admita que todas las soluciones a un problema determinado
son válidas, y por consiguiente simplemente se esté buscando obtener la mejor de
ellas.} en base a una \blue{\textbf{función objetivo}}, entendiendo a esta
última como <<\emph{la función que establece cuándo una solución es mejor que
otra}>>.

\centerbf{Pequeño ejemplo sobre las ideas anteriores}

Un ejemplo concreto de los párrafos anteriores sería un problema en el que se
nos pidiese encontrar una lista de 10 números del 1 al 20, tal que la lista sea
estrictamente creciente. Tendríamos entonces un \darkgreen{problema de
decisión}, en el que la \darkgreen{función de selección} estaría determinada por
las condiciones ``que la lista sea estrictamente creciente'', ``que el número
esté entre 1 y 20'', y ``que el largo de la lista sea 10'' es decir, en donde
tomaríamos como soluciones factibles a todas aquellas en que <<lista[i] $<$
lista[i+1] y además $1 \leq $ lista[i] $ \leq 20$, y además $|$lista$|=
20$>>\footnote{Abusos varios de notación para no ahondar en detalles
innecesarios}. Si se agregara, además, la condición ``quiero de todas las listas
posibles la que maximice la sumatoria de cada uno de sus componentes'', me
encontraría entonces con un \red{problema de optimización}. 

En este ejemplo, entonces, una \textbf{solución factible} sería cualquiera que
cumpla con los criterios de selección, mientras que una \textbf{solución
correctamente formada}, es decir, aquellas que podrían pertenecer a las hojas de
un posible arbol ``universo de soluciones'' (tal y como se menciona en el primer
párrafo), sería simplemente ``una lista de 10 números''\footnote{Esto último es
debatible; habría que formalizar aún más y no viene al caso.}. 

De esta forma, para el ejemplo anterior, se podría establecer un algoritmo en
que cada nodo interno del árbol de soluciones representase la
\textbf{subestructura} de una o más soluciones, sin llegar a ser una solución,
más concretamente, se podría asumir que el nodo raíz del arbol es una lista
vacía, y que cada hijo es una lista que contiene a los elementos de su padre, y
cuyo tamaño es superior en 1, de forma tal que es simple ver que: cada nodo
comparte una subestructura con sus nodos-hermanos heredada desde su nodo-padre,
y sólamente las hojas del arbol son soluciones.

\centerbf{Análisis general}

Siguiendo la línea de pensamiento anterior al ejemplo, teniendo en cuenta todas
las ideas ya expuestas, calcular el gráfo completo del universo de soluciones
(factibles y no factibles) para este problema tendría una complejidad de
\bigO{n^n}, \emph{o incluso infinita} si no se estableciese una asbtracción
idónea al momento de transformar el universo de soluciones en un grafo. Además,
incluso luego de establecer una abstracción en la que el grafo no considerase,
por ejemplo, soluciones imposibles, el tamaño del grafo sigue siendo muy grande
(de orden factorial). Por esta razón, para realizar esta tarea, se utiliza el
concepto de \emph{grafo implícito}, mediante el cual se establece formalmente la
composición del mismo, sin la necesidad de expresar cada una de sus componentes,
\textbf{sino a través de una descripción formal de sus nodos y aristas}, en
donde \textbf{cada nodo es una solución}, y \textbf{cada arista es la
transformación de una solución a una solución distinta dentro de su
\emph{vecindad}} de manera que, dado un caso de prueba particular, sea posible
recrearlo en el momento mismo en que se realiza el recorrido del grafo.

Para este algoritmo en particular, el problema planteado es de
\textbf{optimización}, ya que se desea obtener una solución válida (debe cumplir
ciertos requisitos, como que cada pieza coincida en sus colores con sus
aledañas), pero que además maximice la \red{\textbf{función objetivo}},
definiendo a esta última como, dado un tablero determinado, la sumatoria de los
casilleros que contienen ficha.

% \begin{center}
% \textbf{Formalizando}
% \end{center}

% % - -
% % Definición de pieza

% \begin{notacion}
% Sea $\pi$ el conjunto formado por todas las 4-uplas de la forma
% \[
% p \in \pi \Leftrightarrow \{(\forall~{a, b, c, d} \in \nat)~\exists p = [a, b, c, d]\}
% \]
% \begin{flushright}
% decimos que $p \in \pi$ es una pieza.
% \end{flushright}
% \end{notacion}


% % - -
% % Definición del conjunto de piezas

% \begin{definicion}

% Dado el orden de piezas relativo a la entrada del problema, definimos el
% conjunto ordenado
% \[
% P = \{p_1, ..., p_n\}
% \]
% \begin{center}
% como el conjunto de todas las piezas posibles, de forma tal que 
% \end{center}
% \[
% \{i\geq 1\} \land \{(\forall{i<n})\ p_i < p_{i+1} \Leftrightarrow ``\textbf{pieza~i}"~es~anterior~a~``\textbf{pieza~i+1}"\}
% \]

% \end{definicion}
% \begin{notacion}

% $P[i]$ = $P_i$

% \end{notacion}


% % - -
% % Definición del tablero

% \begin{definicion}

% Sea $T \in \theta$ la sucesión finita de la forma 
% \[
% T = \{p_1, ..., p_n : \{i_{\geq 1}\in\nat\} \land \{(p_i \in \pi) \lor (p_i = ``\texttt{vacio}")\}\},
% \]

% $T$ representa a un tablero, y definimos a cada $T_i = p_i$ como <<el valor de
% la pieza ubicada en la posición $i$ del tablero, o ``\texttt{vacío}'' en el caso de que
% no hubiese ninguna>>

% \end{definicion}

% \begin{notacion}
% $T[i]$ = $T_i$, $\theta$ = <<conjunto de todos los posibles tableros>>
% \end{notacion}
% \begin{definicion}
% sea $t.lleno: \nat_{\geq 1} \rightarrow \nat$, tal que
% \[
%   \left\lbrace
%   \begin{array}{l}
%      t.lleno(i) = verdadero \text{ si } T[i] \neq \texttt{vacio} \\
%      t.lleno(i) = falso \text{ de lo contario} \\
%   \end{array}
%   \right.
% \]
% \end{definicion}
\begin{definicion}
Sean T el conjunto de todos los posibles tableros, 
definimos la función auxiliar 
$t.lleno: \nat_{\geq 1} \rightarrow [0,1]$, tal que
\[
  \left\lbrace
  \begin{array}{l}
     t.lleno(i) = 1 ~~~~~~~~ \text{ si T[i] contiene una pieza} \\
     t.lleno(i) = 0 ~~~~~~~~ \text{ de lo contario} \\
  \end{array}
  \right.
\]
La \red{\textbf{función objetivo}} es, dado un tablero $t \in T$,
$f: T \rightarrow \nat$, de la forma
\red{
\[
f(T) := \nsum_{i=1}^{\#casilleros}{ t.lleno \bigg( {\large T\left(i\right)} \bigg) }
\]
}
\end{definicion}


\subsubsection{Planteamiento de resolución} 

\centerbf{Idea general}

La idea es aplicar el algoritmo de backtracking según las consideraciones expuestas anteriormente. Para ello, recorreremos el tablero en un orden determinado (de izquierda a derecha, de arriba a abajo), evaluando en cada paso la ficha correspondiente a la posición donde se encuentra el recorrido: de tal forma que en cada paso se evalúe la posición siguiente a la que se evaluó en el paso anterior.

En cada paso del algoritmo se colocará una ficha, y luego se continuará hacia el siguiente paso. Es fácil ver que, en su versión más básica, este comportamiento lleva a tener una complejidad del orden de \bigO{N^N}, siendo $N=n*m$ la cantidad de posiciones del tablero, que también es la cantidad de piezas, ya que se realizan N iteraciones (una por cada posición del tablero), y en cada iteración se prueban N piezas, lo cual resulta en $N*N*N*...*N = N^N$. Hay que tener en cuenta que esta forma de recorrer el universo de soluciones está analizando también las soluciones no factibles, es decir las que resultan imposibles, tal como ``colocar la misma pieza en todos los casilleros''.

\centerbf{Poda: Función de Selección}

La primer poda posible resulta totalmente trivial, ya que se trata de probar en cada iteración sólamente las piezas que no se hayan colocado ya en el tablero. De esta forma, se reduce la complejidad a \bigO{(N)*(N-1)*...*(2)*(1)}, es decir al orden factorial \bigO{N!}.

Sobre la misma poda anterior, se puede implementar una mejora, que es probar en cada iteración sólamente las piezas cuyos colores sean coherentes con los colores de las piezas que ya se encuentren colocadas en el tablero. Así, si una posición tiene una pieza a la izquierda cuyo color derecho es verde, yo debería poder colocar en esa posición sólamente las piezas cuyo color izquierdo es verde. Esta última poda en realidad se trata básicamente de reducir el recorrido del universo de soluciones a ``las soluciones factibles'', es decir, las que generan un tablero final válido. Esta última poda en realidad no es distinta a la poda mencionada en el párrafo anterior, sino que es más bien una extensión de la misma, ya que las dos se encargan de analizar en cada iteración la correctitud del tablero en términos de la \textbf{función de selección}.

De esta forma, por lo antes expuesto, podemos asegurar que al final del recorrido (luego de evaluar todas las hojas del árbol) se habrán evaluado todas las soluciones factibles, ya que el algoritmo habrá recorrido cada posición del tablero, evaluando en cada una las piezas que cumplan con el criterio de selección.

\nota{aca poner el pseudocodigo}\\

La idea base es ir llenando el tablero en cierto orden, probando colocar en cada
casillero piezas que no rompan las reglas, y analizando la cantidad total de
piezas del tablero que hayan sido cubiertas. Se debe guardar de alguna forma la
combinación de piezas que haya cubierto más casilleros.\\ Consideramos dejar un
casillero libre como colocar la pieza representada por el 0. En este problema
una solución candidata o rama es una sucesión de piezas (que puede o no incluir
el 0), que van cubriendo el tablero.\\ Una primera decisión que se tomó fue
guardar una estructura piezasPorColores que para cada par de colores (x, y)
guarda una lista con todos las piezas que tienen como color superior e izquierdo
x e y, respectivamente. Vamos recorriendo el tablero en cada fila de izquierda a
derecha, desde la fila superior hasta la inferior. De este modo una pieza es
legal en una posición si su color izquierdo es igual al color derecho de la
pieza a su izquierda (de existir), y su color superior es igual al color
inferior de la pieza ubicada arriba (de existir). Podemos obtener las piezas
candidatas que cumplen con esa restricción de colores en piezasPorColores. De
este modo nos aseguramos que todas las piezas por las que nos vamos ramificando
mantienen las restricciones del tablero. Evitamos así tener que iterar sobre
todas las piezas verificando si cumplen la restricción.\\
Una poda muy sencilla pero muy útil que se 
implementó fue dejar de buscar soluciones cuando encontramos una solución que
cubre todo el tablero. \\
A continuación se detalla otra poda. Vamos
llevando cuenta de los huecos que dejamos en el tablero. Si hemos dejado tantos
huecos como para que, aun llenando correctamente lo que queda del tablero, no
alcanza para superar la mejor solución encontrada hasta el momento, abandonamos
la rama.\\

Al comenzar la búsqueda sabemos que por lo menos vamos a
poder llenar la mitad de los casilleros del tablero. Ésto siempre se puede
conseguir si visualizamos nuestro tablero como uno de ajedrez y ponemos las
piezas en los casilleros negros. Ningún par de piezas compartiría lado. 



\subsubsection{Justificación formal de correctitud}
\nota{Vale por una demostración}

\subsubsection{Cota de complejidad temporal}
\nota{Vale por un análisis teórico}

\subsubsection{Verificación mediante casos de prueba}

A continuación presentamos distintas instancias que sirven para verificar que el programa funciona correctamente.\\

\begin{center}
\begin{minipage}{0.5\textwidth}
	\begin{tabular}{llll}
		Input  \\
		\hline
		n       & m       & c       &         \\
		$sup_1$ & $izq_1$ & $der_1$ & $inf_1$ \\
		\vdots & \vdots   & \vdots  & \vdots  \\
		$sup_{nxm}$ & $izq_{nxm}$ & $der_{nxm}$ & $inf_{nxm}$ \\ 
	\end{tabular} \\  
\end{minipage}
\begin{minipage}{0.5\textwidth}	
	\begin{tabular}{lll}
		Output  \\
		\hline
		$x_1$ & \dots & $x_m$ \\
		\vdots&       & \vdots \\
		$x_n$ & \dots & $x_{nxm}$ \\
		 \\
	\end{tabular} \\
\end{minipage} \\

\begin{minipage}{0.5\textwidth}
\begin{itemize}
	\item{$n$}: \#filas.
	\item{$m$}: \#columnas.
	\item{$c$}: \#colores.
	\item{$sup_i$, $izq_i$, $der_i$, $inf_i$}: colores (entre 1 y c) de los lados de la pieza $i$.
	\item{$x_i$}: número de la pieza en la casilla $i$ del tablero. (``0'' si no hay ninguna pieza).
\end{itemize}
\end{minipage}
\end{center}



Separamos en casos y mostramos ejemplos para cada uno: 
\begin{itemize}
\item Todas las piezas son iguales:
	\begin{itemize}
		\item El tablero se completa. \\
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $1$       \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$3$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$       \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$3$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			
			En estos ejemplos el tablero se completaría colocando las $4$ piezas de cualquier forma. No hay restricciones. \\

		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$).\\
		
		    \begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$       \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $2$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			
			En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
			
	\end{itemize}
\item Todas las piezas son diferentes:
     \begin{itemize}
		\item El tablero se completa. \\
		
		    \begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$3$ $3$ $8$     \\
				    $8$ $2$ $6$ $2$ \\ 
					$1$ $1$ $2$ $4$ \\
					$1$ $2$ $7$ $5$ \\
					$3$ $4$ $4$ $6$ \\
					$4$ $4$ $3$ $7$ \\
					$5$ $3$ $6$ $8$ \\
					$6$ $4$ $1$ $2$ \\
					$7$ $1$ $2$ $7$ \\
					$8$ $8$ $1$ $3$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$9$ $2$ $3$ \\
					$4$ $5$ $6$ \\
					$7$ $8$ $1$ \\
					\\
					\\
					\\
					\\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$). \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $3$ $2$ $2$ \\
					$1$ $1$ $2$ $2$ \\
					$1$ $3$ $2$ $2$ \\
					$2$ $1$ $2$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $2$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
		
		\item El tablero no se completa pero se llena más que el mínimo posible. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$1$ $2$ $1$ $1$ \\
					$1$ $1$ $1$ $2$ \\
					$2$ $2$ $3$ $2$ \\
					$3$ $2$ $3$ $3$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$0$ $3$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
	\end{itemize}
	
\item Existe alguna pieza diferente al resto: 
     \begin{itemize}
		\item El tablero se completa. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$     \\
					$2$ $2$ $1$ $2$ \\
					$2$ $2$ $1$ $2$ \\
					$2$ $1$ $2$ $2$ \\
					$2$ $1$ $2$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $3$ \\
					$2$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$). \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $2$ $1$ $2$ \\
					$3$ $3$ $3$ $1$ \\
					$3$ $2$ $1$ $1$ \\
					$2$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
		
		\item El tablero no se completa pero se llena más que el mínimo posible. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $2$ $1$ $2$ \\
					$3$ $2$ $3$ $1$ \\
					$3$ $1$ $3$ $2$ \\
					$2$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $3$ \\
					$0$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
	\end{itemize}
		
\end{itemize}

Ejecutamos el programa con los distintos ejemplos y se llegó a la solución esperada. Por lo tanto, podemos concluir que el comportamiento del programa es correcto. 

\subsubsection{Medición empírica de la performance}

Para resolver este problema utilizamos la técnica de $Backtracking$. Nos interesa encontrar la forma en que se podrían
colocar las piezas dadas, tal que se llegue a cubrir la mayor parte del tablero siguiendo ciertas reglas. \\
Con esta técnica se estarían probando todas las combinaciones posibles hasta encontrar una solución. Sin embargo, 
esto podría demorar muchísimo, por lo que agregamos algunas podas para no tener que recorrer todas las ramas 
y poder mejorar así, la performance del programa. \\
Una de las podas a analizar es la que lleva cuenta de las casillas que quedaron libres en el tablero, y verifica 
que si aún llenando las casillas restantes, no se llega a una solución mejor que la que ya se tenía, no continúa
por esa rama. \\
Para comprobar que esta poda realmente funciona, medimos los tiempos ejecutando el algoritmo con ella y lo 
comparamos con los tiempos del mismo sin la poda. Durante la medición se fue variando la cantidad de 
piezas totales pasadas como input. Con esto adémas, se quiso observar que la complejidad exponencial calculada era correcta.\\
Otro de los tests a realizar fue comparar la performance del programa, según la distribución de los colores de las
fichas. Es decir, casos con todas las fichas del mismo color o con colores diferentes. \\


%En el gráfico se pueden observar los distintos tiempos obtenidos según se haya utilizado la poda o no. Además, 
%se ve que la complejidad exponencial calculada se cumple. \\






% -----------------------------------------------
\end{document}
