% ------ headers globales y begin ---------------
\documentclass[11pt, a4paper, twoside]{article}
\usepackage{header_tp1}
\begin{document}{}
% -----------------------------------------------

\subsubsection{Descripción}

Este problema consiste en ubicar en un tablero la mayor cantidad de piezas
posibles siguiendo ciertas reglas.

\begin{itemize}   
	\item El tablero contiene $n \times m$ casilleros cuadrados, $n$ filas y $m$
	columnas.

	\item Piezas existentes: $1,...,n \times m$. (Cantidad total de 
	piezas: $n \times m$).

	\item Una pieza es cuadrada y puede tener de $1$ a $4$ colores distintos. 
	A cada lado $(sup, izq, der, inf)$ le corresponde un color. 

	\item Las piezas no se pueden rotar.

	\item Colores posibles: $1,...,c$ ($c$ entero positivo). Como una pieza 
	puede tener como mucho $4$ colores distintos y son $n \times m$ 
	piezas en total, $ 1 \le c \le (4 \times n \times m)$.  

	\item 2 piezas pueden ubicarse en casilleros adyacentes sólo si sus lados 
	adyacentes tienen el mismo color. Podría ocurrir que no sea posible 
	llenar completamente el tablero con las piezas existentes. 

	\item El contenido final de una casilla podría ser $1,...,n \times m$, 
	si se pudo colocar alguna ficha, o $0$ si quedara vacía. 

	\item Cantidad mínima de piezas que se pueden colocar en el tablero: 
	$(n \times m)/ 2$. (Se intercalan las piezas en el tablero).

	Para un tablero de $3\times 3$ y uno de $2\times 2$, suponiendo un caso 
	donde ninguna ficha puede colocarse adyacente a otra, una de las posibles 
	soluciones sería la siguiente:

	En el tablero de $3\times 3$ se podrían colocar las fichas $1,2,3,4$ 
	y $5$, y en el de $2\times 2$, las fichas $1$ y $2$.

	\begin{center}
      \begin{minipage}{0.2\textwidth}
          \begin{tabular}{|c|c|c|}
              \hline
               $1$ & $0$ & $2$ \\
              \hline
               $0$ & $3$ & $0$  \\
              \hline 
               $4$ & $0$ & $5$ \\
              \hline
          \end{tabular}
      \end{minipage}
      \begin{minipage}{0.2\textwidth}
          \begin{tabular}{|c|c|}
              \hline
               $1$ & $0$ \\
              \hline
               $0$ & $2$ \\
              \hline
          \end{tabular}
      \end{minipage}
	\end{center}
\end{itemize} 


\begin{center} 

El problema se deberá resolver utilizando la técnica de $Backtracking$ eligiendo
algunas podas para mejorar los tiempos de ejecución del programa.

\end{center}

\begin{ejemplo}

	Se tiene un tablero de $2\times 2$, los colores $1,2,3$ 
    y las piezas \textbf{1},\textbf{2},\textbf{3},\textbf{4} $:$

  \begin{center}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $1$     &       \\
            $3$  & \textbf{1} &   $2$ \\ 
                 & $2$     &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $3$     &       \\
            $2$  & \textbf{2} & $2$ \\ 
                 & $1$     &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $3$      &       \\
            $1$  & \textbf{2}  & $3$ \\ 
                 & $2$      &       \\
            \hline
        \end{tabular}
    \end{minipage}
    \begin{minipage}{0.2\textwidth}
        \begin{tabular}{ |l l l|}
            \hline
                 & $1$      &       \\
            $1$  & \textbf{4}  & $2$   \\ 
                 & $2$      &       \\
            \hline
        \end{tabular} 
    \end{minipage}
   \end{center}
   
  En este caso, la cantidad máxima de piezas que se pueden colocar en el tablero es $3$. Entonces las posibles soluciones serían:
  
  \begin{center}
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{tabular}{ | l | l |}
            \hline 
            \textbf{1}  & \textbf{2} \\ 
            \hline 
            $0$  & \textbf{4} \\ 
            \hline
        \end{tabular}  \\
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \begin{tabular}{ | l | l |}
            \hline 
            $0$     & \textbf{2} \\ 
            \hline 
            \textbf{3}  & \textbf{1} \\ 
            \hline
        \end{tabular} \\
    \end{minipage}
  \end{center}
\end{ejemplo}

\subsubsection{Hipótesis de resolución} 

El objetivo del problema es diseñar un algoritmo utilizando la técnica de
\textbf{backtracking}. El algoritmo de \textbf{backtracking} se puede concebir
como una técnica recursiva de recorrido de grafos. En este caso, establecemos un
paralelismo entre <<el universo de soluciones>>, y los nodos de un \textbf{grafo
arbol} $n-ario$, en donde cada nodo representa una solución posible, y $n$
representa la cantidad máxima de soluciones distintas que pueden desprenderse a
partir de realizar un cambio determinado en la solución anterior
(\emph{vecindad}).

Calcular todo el gráfo tendría una complejidad de \bigO{n^n}, \emph{o incluso
infinita} si no se estableciese una asbtracción correcta al momento de
transformar el universo de soluciones en un grafo. Por esa razón, para realizar
esta tarea, se utiliza el concepto de \emph{grafo implícito}, mediante el cual
se establece formalmente la composición del mismo, sin la necesidad de expresar
cada una de sus componentes, \textbf{a través de una descripción matemática de
sus nodos y aristas}, en donde \textbf{cada nodo es una solución}, y
\textbf{cada arista es la transformación de una solución a una solución distinta
dentro de su \emph{vecindad}} de manera que, dado un caso de prueba particular,
sea posible recrearlo en el momento mismo en que se realiza el recorrido del
grafo.

Podemos separar el tipo de problema en dos casos: \textbf{problemas de
decisión}, para los que es necesario que la solución cumpla ciertas condiciones
particulares, y \textbf{problemas de optimización}, en donde se desea obtener la
mejor de las soluciones válidas en base a una \textbf{función objetivo},
entendiendo a esta última como <<la función que establece cuándo una solución es
mejor que otra>>. Para este algoritmo en particular, el problema planteado es de
\textbf{optimización}, ya que se desea obtener la solución válida (debe cumplir
ciertos requisitos) que maximice la función objetivo, definiéndola como la
sumatoria de los casilleros completos de un tablero determinado.

\begin{center}
\textbf{Formalizando}
\end{center}

% - -
% Definición de pieza

\begin{notacion}
Sea $\pi$ el conjunto formado por todas las 4-uplas de la forma
\[
p \in \pi \Leftrightarrow \{(\forall~{a, b, c, d} \in \nat)~\exists p = [a, b, c, d]\}
\]
\begin{flushright}
decimos que $p \in \pi$ es una pieza.
\end{flushright}
\end{notacion}


% - -
% Definición del conjunto de piezas

\begin{definicion}

Dado el orden de piezas relativo a la entrada del problema, definimos el
conjunto ordenado
\[
P = \{p_1, ..., p_n\}
\]
\begin{center}
como el conjunto de todas las piezas posibles, de forma tal que 
\end{center}
\[
\{i\geq 1\} \land \{(\forall{i<n})\ p_i < p_{i+1} \Leftrightarrow ``\textbf{pieza~i}"~es~anterior~a~``\textbf{pieza~i+1}"\}
\]

\end{definicion}
\begin{notacion}

$P[i]$ = $P_i$

\end{notacion}


% - -
% Definición del tablero

\begin{definicion}

Sea $T \in \theta$ la sucesión finita de la forma 
\[
T = \{p_1, ..., p_n : \{i_{\geq 1}\in\nat\} \land \{(p_i \in \pi) \lor (p_i = ``\texttt{vacio}")\}\},
\]

$T$ representa a un tablero, y definimos a cada $T_i = p_i$ como <<el valor de
la pieza ubicada en la posición $i$ del tablero, o ``\texttt{vacío}'' en el caso de que
no hubiese ninguna>>

\end{definicion}

\begin{notacion}
$T[i]$ = $T_i$, $\theta$ = <<conjunto de todos los posibles tableros>>
\end{notacion}
\begin{definicion}
sea $t.lleno: \nat_{\geq 1} \rightarrow \nat$, tal que
\[
  \left\lbrace
  \begin{array}{l}
     t.lleno(i) = verdadero \text{ si } T[i] \neq \texttt{vacio} \\
     t.lleno(i) = falso \text{ de lo contario} \\
  \end{array}
  \right.
\]
\end{definicion}
\begin{definicion}
La función objetivo es, dado un tablero $T$, $f: \theta \rightarrow \nat$, de la forma
\end{definicion}
\[
f(T) := \nsum_{i=1}^{i\leq casilleros}{ t.lleno \bigg( {\large T\left(i\right)} \bigg) }
\]

La idea base es ir llenando el tablero en cierto orden, probando colocar en cada
casillero piezas que no rompan las reglas, y analizando la cantidad total de
piezas del tablero que hayan sido cubiertas. Se debe guardar de alguna forma la
combinación de piezas que haya cubierto más casilleros. Consideramos dejar un
casillero libre como colocar la pieza representada por el 0. En este problema
una solución candidata o rama es una sucesión de piezas (que puede o no incluir
el 0), que van cubriendo el tablero. Una primera decisión que se tomo fue
guardar una estructura piezasPorColores que para cada par de colores (x, y)
guarda una lista con todos las piezas que tienen como color superior e izquierdo
x e y, respectivamente. Vamos recorriendo el tablero en cada fila de izquierda a
derecha, desde la fila superior hasta la inferior. De este modo una pieza es
legal en una posición si su color izquierdo es igual al color derecho de la
pieza a su izquierda (de existir), y su color superior es igual al color
inferior de la pieza ubicada arriba (de existir). Podemos obtener las piezas
candidatas que cumplen con esa restricción de colores en piezasDeColores. De
este modo nos aseguramos que todas las piezas por las que nos vamos ramificando
mantienen las restricciones del tablero. Evitamos asi tener que iterar sobre
todas las piezas verificando si cumplen la restricción. Una poda trivial que se
implementó fue dejar de buscar soluciones cuando encontramos una solución que
cubre todo el tablero. Al comenzar la búsqueda sabemos que por lo menos vamos a
poder llenar la mitad de los casilleros del tablero. Ésto siempre se puede
conseguir si visualizamos nuestro tablero como uno de ajedrez y ponemos las
piezas en los casilleros negros. Ningun par de piezas compartiría lado. Vamos
llevando cuenta de los huecos que dejamos en el tablero. Si hemos dejado tantos
huecos como para que, aun llenando correctamente lo que queda del tablero, no
alcanza para superar la mejor solución encontrada hasta el momento, abandonamos
la rama.



\subsubsection{Justificación formal de correctitud}
\nota{Vale por una demostración}

\subsubsection{Cota de complejidad temporal}
\nota{Vale por un análisis teórico}

\subsubsection{Verificación mediante casos de prueba}

A continuación presentamos distintas instancias que sirven para verificar que el programa funciona correctamente.\\

\begin{center}
\begin{minipage}{0.5\textwidth}
	\begin{tabular}{llll}
		Input  \\
		\hline
		n       & m       & c       &         \\
		$sup_1$ & $izq_1$ & $der_1$ & $inf_1$ \\
		\vdots & \vdots   & \vdots  & \vdots  \\
		$sup_{nxm}$ & $izq_{nxm}$ & $der_{nxm}$ & $inf_{nxm}$ \\ 
	\end{tabular} \\  
\end{minipage}
\begin{minipage}{0.5\textwidth}	
	\begin{tabular}{lll}
		Output  \\
		\hline
		$x_1$ & \dots & $x_m$ \\
		\vdots&       & \vdots \\
		$x_n$ & \dots & $x_{nxm}$ \\
		 \\
	\end{tabular} \\
\end{minipage} \\

\begin{minipage}{0.5\textwidth}
\begin{itemize}
	\item{$n$}: \#filas.
	\item{$m$}: \#columnas.
	\item{$c$}: \#colores.
	\item{$sup_i$, $izq_i$, $der_i$, $inf_i$}: colores (entre 1 y c) de los lados de la pieza $i$.
	\item{$x_i$}: número de la pieza en la casilla $i$ del tablero. (``0'' si no hay ninguna pieza).
\end{itemize}
\end{minipage}
\end{center}



Separamos en casos y mostramos ejemplos para cada uno: 
\begin{itemize}
\item Todas las piezas son iguales:
	\begin{itemize}
		\item El tablero se completa. \\
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $1$       \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
					$1$ $1$ $1$ $1$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$3$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$       \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
					$1$ $2$ $2$ $1$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$3$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			
			En estos ejemplos el tablero se completaría colocando las $4$ piezas de cualquier forma. No hay restricciones. \\

		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$).\\
		
		    \begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$       \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
					$1$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $2$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
			
			En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
			
	\end{itemize}
\item Todas las piezas son diferentes:
     \begin{itemize}
		\item El tablero se completa. \\
		
		    \begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$3$ $3$ $8$     \\
				    $8$ $2$ $6$ $2$ \\ 
					$1$ $1$ $2$ $4$ \\
					$1$ $2$ $7$ $5$ \\
					$3$ $4$ $4$ $6$ \\
					$4$ $4$ $3$ $7$ \\
					$5$ $3$ $6$ $8$ \\
					$6$ $4$ $1$ $2$ \\
					$7$ $1$ $2$ $7$ \\
					$8$ $8$ $1$ $3$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$9$ $2$ $3$ \\
					$4$ $5$ $6$ \\
					$7$ $8$ $1$ \\
					\\
					\\
					\\
					\\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$). \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $3$ $2$ $2$ \\
					$1$ $1$ $2$ $2$ \\
					$1$ $3$ $2$ $2$ \\
					$2$ $1$ $2$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $2$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
		
		\item El tablero no se completa pero se llena más que el mínimo posible. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$1$ $2$ $1$ $1$ \\
					$1$ $1$ $1$ $2$ \\
					$2$ $2$ $3$ $2$ \\
					$3$ $2$ $3$ $3$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $2$ \\
					$0$ $3$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
	\end{itemize}
	
\item Existe alguna pieza diferente al resto: 
     \begin{itemize}
		\item El tablero se completa. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $2$     \\
					$2$ $2$ $1$ $2$ \\
					$2$ $2$ $1$ $2$ \\
					$2$ $1$ $2$ $2$ \\
					$2$ $1$ $2$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $3$ \\
					$2$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		\item El tablero tiene la mínima cantidad de piezas (($n \times m)/2$). \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $2$ $1$ $2$ \\
					$3$ $3$ $3$ $1$ \\
					$3$ $2$ $1$ $1$ \\
					$2$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $0$ \\
					$0$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} 
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$0$ $1$ \\
					$2$ $0$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
		En este caso sólo se pueden colocar las piezas intercaladas. Se podrían tomar $2$ piezas cualesquiera para la solución (Ej: piezas $3$ y $4$). \\
		
		\item El tablero no se completa pero se llena más que el mínimo posible. \\
		
			\begin{minipage}{0.2\textwidth}
				\begin{tabular}{l}
					Input  \\
					\hline
					$2$ $2$ $3$     \\
					$2$ $2$ $1$ $2$ \\
					$3$ $2$ $3$ $1$ \\
					$3$ $1$ $3$ $2$ \\
					$2$ $2$ $1$ $2$ \\
				\end{tabular} \\  
			\end{minipage}
			\begin{minipage}{0.2\textwidth}	
				\begin{tabular}{l}
					Output  \\
					\hline
					$1$ $3$ \\
					$0$ $4$ \\
					\\
					\\
					\\
				\end{tabular} \\
			\end{minipage} \\
		
	\end{itemize}
		
\end{itemize}

Ejecutamos el programa con los distintos ejemplos y se llegó a la solución esperada. Por lo tanto, podemos concluir que el comportamiento del programa es correcto. 

\subsubsection{Medición empírica de la performance}

Para resolver este problema utilizamos la técnica de $Backtracking$. Nos interesa encontrar la forma en que se podrían
colocar las piezas dadas, tal que se llegue a cubrir la mayor parte del tablero siguiendo ciertas reglas. \\
Con esta técnica se estarían probando todas las combinaciones posibles hasta encontrar una solución. Sin embargo, 
esto podría demorar muchísimo, por lo que agregamos algunas podas para no tener que recorrer todas las ramas 
y poder mejorar así, la performance del programa. \\
Una de las podas a analizar es la que lleva cuenta de las casillas que quedaron libres en el tablero, y verifica 
que si aún llenando las casillas restantes, no se llega a una solución mejor que la que ya se tenía, no continúa
por esa rama. \\
Para comprobar que esta poda realmente funciona, medimos los tiempos ejecutando el algoritmo con ella y lo 
comparamos con los tiempos del mismo sin la poda. Durante la medición se fue variando la cantidad de 
piezas totales pasadas como input.  \\
En el gráfico se pueden observar los distintos tiempos obtenidos según se haya utilizado la poda o no. Además, 
se ve que la complejidad exponencial calculada se cumple. \\


%Gráfico1 
%Otro de los tests realizados fue comparar la performance del programa, según la distribución de los colores de las
%fichas. Es decir, casos con todas las fichas del mismo color o con colores diferentes. \\

%Gráfico2


% -----------------------------------------------
\end{document}
