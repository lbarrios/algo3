% ------ headers globales y begin ---------------
\documentclass[11pt, a4paper, twoside]{article}
\usepackage{header_tp1}
\begin{document}{}
% -----------------------------------------------
\subsubsection{Problema 3: Rompecolores }
\lstset{caption={ej3.cpp},label=ej3}
\begin{lstlisting}

#include "ej3.h"
#include "Tablero.h"
#include "IndiceDePiezas.h"

Tablero& backtrack( Tablero&, IndiceDePiezas&, uint32_t );
void imprimeTablero( Tablero& );

int main( int argc, char** argv )
{
  // Parseo los parametros con que fue llamado el ejecutable
  ParserDeParametros parser( argc, argv );
  // Esta clase representa un caso de prueba, y lo toma desde el input que le provee el parser
  TestCaseEj3 testcase ( parser.dameInput() );

  // Itero sobre los distintos casos de prueba hasta obtener un testcase nulo
  while ( testcase.tomarDatos() != false )
  {
    // Obtengo los parametros del testcase.
    uint32_t cantidadDeFilas = testcase.dameCantidadDeFilas();
    uint32_t cantidadDeColumnas = testcase.dameCantidadDeColumnas();
    uint32_t cantidadDeColores = testcase.dameCantidadDeColores();
    vector<TestCaseEj3::Pieza>& listaDePiezas = testcase.dameListaDePiezas();
    // Inicializo el tablero (estructura auxiliar)
    Tablero tablero( cantidadDeFilas, cantidadDeColumnas, listaDePiezas );
    // Inicializo el indice de piezas (estructura auxiliar)
    IndiceDePiezas indiceDePiezas( cantidadDeColores, listaDePiezas, tablero );
    //Obtengo el mejor tablero a traves de backtracking
    Tablero& mejorTablero = backtrack( tablero, indiceDePiezas, 0 );

    // Devuelvo el resultado con el formato solicitado

    for ( uint32_t columna = 0; columna < mejorTablero.cantidadDeColumnas; columna++ )
    {
      for ( uint32_t fila = 0; fila < mejorTablero.cantidadDeFilas; fila++ )
      {
        uint32_t posicion = ( columna * mejorTablero.cantidadDeFilas ) + fila;
        uint32_t pieza = mejorTablero[ posicion ];
        parser.dameOutput() << pieza << " ";
      }

      parser.dameOutput() << endl;
    }

    delete &mejorTablero;
  }

  return 0;
}

Tablero& backtrack( Tablero& t, IndiceDePiezas& ip, uint32_t posicion )
{
  DEBUG_ENTER; _C( "Entrando a recursion en posicion: " << posicion + 1 );
  Tablero* mejorTablero = NULL;

	#ifndef SINPODAOBJETIVO
  if ( t.yaEncontreUnTableroMejor( posicion ) )
  {
    _C( "PODANDO EN POS " << posicion <<" PORQUE EXISTE UN TABLERO mejor QUE CUALQUIERA DE ESTA RAMA" );
    return *mejorTablero;
  }
  #endif
  

  IteradorIndiceDePiezas& it = ip.dameIterador( posicion );
  _C("Obtenido iterador al indice de piezas");

  // Me fijo si estoy antes de la ultima posicion
  if ( posicion < t.cantidadDePosiciones - 1 )
  {
    while ( it.hayPiezasPosibles() )
    {
      _C( "Pieza disponible: " << *it );
      // Si es asi, entonces llamo a backtrack para cada pieza posible
      t.ponerPiezaEnPosicion( *it, posicion );
      ip.marcarPiezaUtilizada( it );
      // Hago recursion en el backtracking
      Tablero* otroTablero = NULL;
      otroTablero = &( backtrack( t, ip, posicion + 1 ) );
      _C( "VOLVIENDO A POSICION " << posicion );

      if ( !mejorTablero )
      {
        mejorTablero = otroTablero;
      }
      else
      {
        if ( !otroTablero )
        {
          ip.marcarPiezaDisponible ( it );
          // Si la recursion me devolvio un puntero a nulo termino el BT
          break;
        }
        else
        {
          if ( *mejorTablero < *otroTablero )
          {
            delete mejorTablero;
            mejorTablero = otroTablero;
          }
          else
          {
            delete otroTablero;
          }
        }
      }

      ip.marcarPiezaDisponible ( it );
      it++;
    }
  }
  else
  {
    // (si estoy en la ultima posicion del tablero)
    // Intento colocar la ultima pieza
    if ( it.hayPiezasPosibles() )
    {
      t.ponerPiezaEnPosicion( *it, posicion );
    }

    // Creo una copia del tablero final
    mejorTablero = new Tablero( t );
    // Pongo una pieza transparente en el lugar donde puse (o no) una pieza
    t.ponerPiezaEnPosicion( TestCaseEj3::PIEZA_VACIA, posicion );
  }

  delete (&it);
  _C( "Saliendo de recursion en posicion: " << posicion + 1 ); DEBUG_ENTER;
  return *mejorTablero;
}

/**
 * Dado un tablero, lo imprime a consola (stderr).
 */
void imprimeTablero( Tablero& t )
{
  for ( uint32_t y = 0; y < t.cantidadDeFilas; y++ )
  {
    for ( uint32_t x = 0; x < t.cantidadDeColumnas; x++ )
    {
      uint32_t posicion = y * t.cantidadDeColumnas + x;
      cerr << t[posicion] << " ";
    }

    cerr << endl;
  }

  cerr << endl;
}

\end{lstlisting}
\clearpage

\lstset{caption={Tablero.h},label=ej3}
\begin{lstlisting}

#ifndef __TABLERO_H__
#define __TABLERO_H__
#include "ej3.h"

class Tablero
{
private:
  vector<TestCaseEj3::Pieza>& _listaDePiezas;
  vector<uint32_t> _piezasEnElTablero;
  uint32_t _cantidadDePosicionesVacias;
  uint32_t _mejorCantidadDePosicionesVacias;

  // Poda
  uint32_t _mejorCantidadDePosicionesVaciasPosible;
  void _calcularMejorCantidadDePiezasPosible();
  uint32_t _ultimaPosicionAgregada;
public:
  Tablero( uint32_t p_filas, uint32_t p_columnas, vector<TestCaseEj3::Pieza>& );
  /**
   * Operador binario, indica si un tablero es menor a otro
   */
  inline bool operator< ( Tablero& t )
  {
    return this->_cantidadDePosicionesVacias > t._cantidadDePosicionesVacias;
  }
  /**
   * Permite acceder a la pieza ubicada en una posicion determinada
   */
  const inline uint32_t& operator[] ( uint32_t posicion ) const
  {
    return this->_piezasEnElTablero[posicion];
  }
  /**
   * Dada una posicion en el tablero,
   * devuelve la pieza que se encuentra a la izquierda
   */
  const uint32_t dameLaPiezaDeIzquierdaDePosicion( uint32_t );
  /**
   * Dada una posicion en el tablero,
   * devuelve la pieza que se encuentra arriba
   */
  const uint32_t dameLaPiezaDeArribaDePosicion( uint32_t );

 
  /**
   * Coloca una pieza en la posicion indicada
   */
  void ponerPiezaEnPosicion( uint32_t, uint32_t );
  const uint32_t cantidadDeFilas;
  const uint32_t cantidadDeColumnas;
  const uint32_t cantidadDePosiciones;
  inline const uint32_t cantidadDePosicionesLlenas( void )
  {
    return this->cantidadDePosiciones - this->_cantidadDePosicionesVacias;
  };

  bool yaEncontreElMejorTableroPosible( void );
  bool yaEncontreUnTableroMejor( uint32_t );
  void imprimeTablero();
private:

};

#endif

\end{lstlisting}
\clearpage


\lstset{caption={Tablero.cpp},label=ej3}
\begin{lstlisting}

#include "Tablero.h"

Tablero::Tablero( uint32_t p_filas, uint32_t p_columnas, vector<TestCaseEj3::Pieza>& listaDePiezas )
  :
  _listaDePiezas( listaDePiezas ),
  _cantidadDePosicionesVacias( p_filas* p_columnas ),
  _mejorCantidadDePosicionesVacias( _cantidadDePosicionesVacias/2 + 1 ),
  cantidadDeFilas( p_filas ),
  cantidadDeColumnas( p_columnas ),
  cantidadDePosiciones( p_filas* p_columnas )
{
  this->_piezasEnElTablero.assign( p_filas * p_columnas, 0 );
  // Poda
  this->_calcularMejorCantidadDePiezasPosible();
}
const uint32_t Tablero::dameLaPiezaDeArribaDePosicion( uint32_t posicion )
{
  bool noEsPrimeraFila = ( posicion >= this->cantidadDeColumnas );

  if ( noEsPrimeraFila )
  {
    _C( "La pieza arriba de la posicion " << posicion + 1 << " es: " <<
        this->_piezasEnElTablero[posicion - this->cantidadDeColumnas] );
    return this->_piezasEnElTablero[posicion - this->cantidadDeColumnas];
  }
  else
  {
    _C( "La posicion " << posicion + 1 << " contiene una pieza vacia a arriba" );
    return TestCaseEj3::PIEZA_VACIA;
  }
}
const uint32_t Tablero::dameLaPiezaDeIzquierdaDePosicion( uint32_t posicion )
{
  bool noEsPrimeraColumna = ( posicion % this->cantidadDeFilas != 0 );

  if ( noEsPrimeraColumna )
  {
    _C( "La pieza izquierda de la posicion " << posicion + 1 << " es: " << this->_piezasEnElTablero[posicion - 1] );
    return this->_piezasEnElTablero[posicion - 1];
  }
  else
  {
    _C( "La posicion " << posicion + 1 << " contiene una pieza vacia a su izquierda" );
    return TestCaseEj3::PIEZA_VACIA;
  }
}

void Tablero::ponerPiezaEnPosicion( uint32_t pieza, uint32_t posicion )
{
  _C( "Poniendo pieza: " << pieza << " en posicion: " << posicion + 1 );

  if ( this->_piezasEnElTablero[posicion] == TestCaseEj3::PIEZA_VACIA )
  {
    if ( pieza != TestCaseEj3::PIEZA_VACIA )
    {
      this->_cantidadDePosicionesVacias--;
      this->_piezasEnElTablero[posicion] = pieza;

      if ( this->_cantidadDePosicionesVacias < this->_mejorCantidadDePosicionesVacias )
      {
        _C( "Se encontro un nuevo mejor tablero, con " << this->_cantidadDePosicionesVacias << " posiciones vacias, la mejor era " <<
            this->_mejorCantidadDePosicionesVacias << "." );
        this->_mejorCantidadDePosicionesVacias = this->_cantidadDePosicionesVacias;
      }
    }
  }
  else
  {
    if ( pieza == TestCaseEj3::PIEZA_VACIA )
    {
      this->_cantidadDePosicionesVacias++;
    }

    this->_piezasEnElTablero[posicion] = pieza;
  }

#ifdef DEBUG
  this->imprimeTablero();
#else

#endif
  this->_ultimaPosicionAgregada = posicion;
}

bool Tablero::yaEncontreElMejorTableroPosible( void )
{
  return _mejorCantidadDePosicionesVacias <= this->_mejorCantidadDePosicionesVaciasPosible;
}
bool Tablero::yaEncontreUnTableroMejor ( uint32_t posicion )
{
  DEBUG_INT(this->_mejorCantidadDePosicionesVacias);
  DEBUG_INT(this->cantidadDePosiciones);
  DEBUG_INT(posicion);
  DEBUG_INT(this->_mejorCantidadDePosicionesVacias + this->cantidadDePosiciones - posicion);
  DEBUG_INT(_cantidadDePosicionesVacias);
  return this->_mejorCantidadDePosicionesVacias + this->cantidadDePosiciones - posicion
  <= _cantidadDePosicionesVacias;
}
void Tablero::imprimeTablero()
{
  for ( uint32_t y = 0; y < this->cantidadDeFilas; y++ )
  {
    for ( uint32_t x = 0; x < this->cantidadDeColumnas; x++ )
    {
      uint32_t posicion = y * this->cantidadDeColumnas + x;
      cerr << Tablero::operator[]( posicion ) << " ";
    }

    cerr << endl;
  }
}
void Tablero::_calcularMejorCantidadDePiezasPosible()
{
  _mejorCantidadDePosicionesVaciasPosible = 0;
  return;

  multiset<uint32_t> coloresIzquierda;
  multiset<uint32_t> coloresDerecha;
  multiset<uint32_t> coloresArriba;
  multiset<uint32_t> coloresAbajo;

  for ( uint32_t i = 1; i < this->_listaDePiezas.size(); i++ )
  {
    coloresIzquierda.insert( this->_listaDePiezas[i].colorIzquierda );
    coloresDerecha.insert( this->_listaDePiezas[i].colorDerecha );
    coloresArriba.insert( this->_listaDePiezas[i].colorArriba );
    coloresAbajo.insert( this->_listaDePiezas[i].colorAbajo );
  }

  multiset<uint32_t>::iterator it, it2;

  for ( it = coloresIzquierda.begin(); it != coloresIzquierda.end(); it++ )
  {
    it2 = coloresDerecha.find( *it );

    if ( it2 != coloresDerecha.end() )
    {
      coloresDerecha.erase( it2 );
    }
  }

  for ( it = coloresDerecha.begin(); it != coloresDerecha.end(); it++ )
  {
    it2 = coloresIzquierda.find( *it );

    if ( it2 != coloresIzquierda.end() )
    {
      coloresIzquierda.erase( it2 );
    }
  }

  for ( it = coloresArriba.begin(); it != coloresArriba.end(); it++ )
  {
    it2 = coloresAbajo.find( *it );

    if ( it2 != coloresAbajo.end() )
    {
      coloresAbajo.erase( it2 );
    }
  }

  for ( it = coloresAbajo.begin(); it != coloresAbajo.end(); it++ )
  {
    it2 = coloresArriba.find( *it );

    if ( it2 != coloresArriba.end() )
    {
      coloresArriba.erase( it2 );
    }
  }

  uint32_t piezasInfumables = max( coloresDerecha.size(), max( coloresIzquierda.size(), max( coloresArriba.size(), coloresAbajo.size() ) ) );
  _C( "Atencion: Hay como minimo " << piezasInfumables << " piezas incompatibles en este tablero" );
  this->_mejorCantidadDePosicionesVaciasPosible = piezasInfumables / 2;
  this->_mejorCantidadDePosicionesVaciasPosible = 0;
  _C( "Atencion: Se estima un minimo de " << this->_mejorCantidadDePosicionesVaciasPosible << " posiciones en blanco para este tablero." );

}

\end{lstlisting}
\clearpage


\lstset{caption={IndiceDePiezas.h},label=ej3}
\begin{lstlisting}

#ifndef __INDICEDEPIEZAS_H__
#define __INDICEDEPIEZAS_H__
#include "ej3.h"
#include "Tablero.h"

class IteradorIndiceDePiezas;
class IndiceDePiezas
{
  friend class IteradorIndiceDePiezas;
private:
  Tablero& _t;
  vector<TestCaseEj3::Pieza>& _listaDePiezas;
  vector<IteradorIndiceDePiezas*> _iteradores;
  typedef vector<uint32_t> listaDePiezas;
  vector< vector< stack< listaDePiezas > > > _indiceDeDosColores;
  vector<bool> _indicePiezasDisponibles;
  stack< listaDePiezas > _indiceSecuencial;
  void _imprimirIndiceDeDosColores();

public:
  IndiceDePiezas( uint32_t, vector<TestCaseEj3::Pieza>&, Tablero& );
  ~IndiceDePiezas();
  IteradorIndiceDePiezas& dameIterador( uint32_t );
  bool puedeColorarPiezaEnPosicion( uint32_t, uint32_t );
  void marcarPiezaUtilizada( IteradorIndiceDePiezas& );
  void marcarPiezaDisponible( IteradorIndiceDePiezas& );

};

#include "IteradorIndiceDePiezas.h"

#endif

\end{lstlisting}
\clearpage


\lstset{caption={IndiceDePiezas.cpp},label=ej3}
\begin{lstlisting}

#include "IndiceDePiezas.h"

IndiceDePiezas::IndiceDePiezas( uint32_t p_cantidadDeColores, vector<TestCaseEj3::Pieza>& p_listaDePiezas, Tablero& t ):
  _t( t ),
  _listaDePiezas( p_listaDePiezas ),
  _indiceDeDosColores(
    p_cantidadDeColores + 1,
    vector< stack< listaDePiezas > >(
      p_cantidadDeColores + 1,
      stack< listaDePiezas >(
        deque<listaDePiezas>( 1, listaDePiezas( 0 ) )
      )
    )
  ),
  _indicePiezasDisponibles(
    p_listaDePiezas.size(), true
  ),
  _indiceSecuencial(
    deque<listaDePiezas>( 1, listaDePiezas( 0 ) )
  )
{
  for ( uint32_t i = 1; i < this->_listaDePiezas.size(); i++ )
  {
    TestCaseEj3::Pieza pieza = this->_listaDePiezas[i];
    uint32_t colorIzquierda = pieza.colorIzquierda;
    uint32_t colorArriba = pieza.colorArriba;
    _indiceDeDosColores[colorIzquierda][colorArriba].top().push_back( i );
    _indiceSecuencial.top().push_back( i );
  }
  _imprimirIndiceDeDosColores();
}

void IndiceDePiezas::_imprimirIndiceDeDosColores(){
  for ( uint32_t i = 1; i<_indiceDeDosColores.size(); i++){
    for ( uint32_t j = 1; j<_indiceDeDosColores.size(); j++){
      //_C("i="<<i<<", j="<<j<<" .size = "<< _indiceDeDosColores[i][j].top().size());
      for ( vector<uint32_t>::iterator it = _indiceDeDosColores[i][j].top().begin(); it!=_indiceDeDosColores[i][j].top().end(); it++ )
        _C("IC["<<i<<"]["<<j<<"] = "<<*it);
    }
  }
}


IteradorIndiceDePiezas& IndiceDePiezas::dameIterador( uint32_t posicion )
{
  IteradorIndiceDePiezas* it = NULL;
  // Obtengo las piezas de la izquierda y de arriba
  uint32_t piezaIzquierda = _t.dameLaPiezaDeIzquierdaDePosicion( posicion );
  uint32_t piezaArriba = _t.dameLaPiezaDeArribaDePosicion( posicion );

  //it = new IteradorIndiceDePiezas( posicion );
  #ifndef SINPODAOBJETIVO
  bool arribaVacio = (piezaArriba == TestCaseEj3::PIEZA_VACIA);
  bool izquierdaVacio = (piezaIzquierda == TestCaseEj3::PIEZA_VACIA);
  if ( arribaVacio || izquierdaVacio )
  {
    _C("Creando iterador secuencial");
    it = new IteradorSecuencial( *this, posicion );
  }
  else
  {
    _C("Creando iterador por colores");
    it = new IteradorColores( *this, posicion );
  }
  #else
  _C("Creando iterador secuencial");
  it = new IteradorSecuencial( *this, posicion );
  #endif

  return *it;
}
void IndiceDePiezas::marcarPiezaUtilizada( IteradorIndiceDePiezas& it )
{
  _C( "Marcando como utilizada la pieza: " << *it );

  if ( *it == TestCaseEj3::PIEZA_VACIA )
  {
    _C( "La pieza es vacia" );
    it.utilizarPiezaTransparente();
  }
  else
  {

  _imprimirIndiceDeDosColores();

    // Marco la pieza como no disponible
    this->_indicePiezasDisponibles[*it] = false;
    // Obtengo la pieza del listado de piezas
    TestCaseEj3::Pieza pieza = this->_listaDePiezas[*it];
    _C("Pusheo una copia del indice para esos dos colores");
    this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].push(
      this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].top()
    );
    _C("Borro el elemento de la nueva lista");
    this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].top().erase(
      lower_bound( this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].top().begin(),
                   this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].top().end(), *it )
    );
    _C("Pusheo una copia del indice secuencial");
    this->_indiceSecuencial.push(
      this->_indiceSecuencial.top()
    );
    _C("Borro el elemento del indice secuencial");
    this->_indiceSecuencial.top().erase(
      lower_bound( this->_indiceSecuencial.top().begin(),
        this->_indiceSecuencial.top().end(), *it)
    );
    DEBUG_INT(this->_indiceSecuencial.top().size());
  }
}
void IndiceDePiezas::marcarPiezaDisponible( IteradorIndiceDePiezas& it )
{
  if ( *it != TestCaseEj3::PIEZA_VACIA )
  {
    _C( "Marcando como disponible la pieza: " << *it );
    // Marco la pieza como disponible
    this->_indicePiezasDisponibles[*it] = true;
    // Obtengo la pieza del listado de piezas
    TestCaseEj3::Pieza pieza = this->_listaDePiezas[*it];
    this->_indiceDeDosColores[pieza.colorIzquierda][pieza.colorArriba].pop();
    this->_indiceSecuencial.pop();
  }
}

bool IndiceDePiezas::puedeColorarPiezaEnPosicion( uint32_t i_pieza, uint32_t posicion )
{
  TestCaseEj3::Pieza pieza = this->_listaDePiezas[i_pieza];
  uint32_t piezaArriba = this->_t.dameLaPiezaDeArribaDePosicion( posicion );
  bool arriba = piezaArriba == TestCaseEj3::PIEZA_VACIA || pieza.colorArriba == this->_listaDePiezas[piezaArriba].colorAbajo;
  uint32_t piezaIzquierda = this->_t.dameLaPiezaDeIzquierdaDePosicion( posicion );
  bool izquierda = piezaIzquierda == TestCaseEj3::PIEZA_VACIA || pieza.colorIzquierda == this->_listaDePiezas[piezaIzquierda].colorDerecha;
  return arriba && izquierda;
}

\end{lstlisting}
\clearpage

\lstset{caption={IndiceDeColores.h},label=ej3}
\begin{lstlisting}

#ifndef __INDICEDECOLORES_H__
#define __INDICEDECOLORES_H__
#include "ej3.h"

class IndiceDeColores 
{
private:
  struct piezaIndexada
  {
    piezaIndexada (uint32_t ip, uint32_t id) : indiceEnListaDePiezas(ip), indiceEnListaDisponibles(id) {};
    uint32_t indiceEnListaDePiezas;
    uint32_t indiceEnListaDisponibles;
  };
  struct listaDisponibles
  {
    listaDisponibles( ) : principio(0){ };
    vector< piezaIndexada > lista;
    uint32_t principio;
  };
  vector<TestCaseEj3::Pieza> &listaDePiezas;
  vector< vector< listaDisponibles > > v;
  inline uint32_t colorDerecha (uint32_t indice)
  {
    return this->listaDePiezas[indice].colorDerecha - 1;
  }
  inline uint32_t colorAbajo (uint32_t indice)
  {
    return this->listaDePiezas[indice].colorAbajo - 1;
  }
public:
  struct Iterador{
    IndiceDeColores& _ic;
    inline void quitarPieza()
    {
      (this->_ic.*_quitarPieza)( *this );
    }
    vector< vector< listaDisponibles > >& _v;
    vector< piezaIndexada >* _v_res;
    uint32_t _indice;
    bool _primeraColumna;
    bool _primeraFila;
    uint32_t _colorDerechaActual;
    uint32_t _colorAbajoActual;
    bool _piezaTransparenteUtilizada;
    void (Iterador::*_avanza)();
    bool (Iterador::*_hayPosibles)();
    void (IndiceDeColores::*_quitarPieza)( IndiceDeColores::Iterador & );
    /**
     * Inicializa el iterador
     */
    inline void _avanzaIteradorNormal() {
      this->_indice++;
    }
    inline void _avanzaIteradorPrimerCasillero()
    {
      _C("_avanzaIteradorPrimerCasillero();");
      this->_avanzaIteradorNormal();
      if ( !this->_hayPosiblesNormal() )
      {
        _C("No hay posibles en este color " << this->_colorAbajoActual);
        listaDisponibles l;
        while(true)
        {
          this->_colorAbajoActual++;
          if (this->_colorAbajoActual >= this->_v.size())
          {
            this->_colorAbajoActual = 0;
            this->_colorDerechaActual++;
          }
          l = _v[this->_colorDerechaActual][this->_colorAbajoActual];
          if ((l.lista.size() - l.principio) > 0)
          {
            _C("Encontrado color disponible: derecha:" << this->_colorDerechaActual << ", abajo: " << this->_colorAbajoActual);
            break;
          }
        }
        this->_v_res = &(l.lista);
        this->_indice = l.principio;
      }
    }
    inline void _avanzaIteradorPrimeraColumna(){
      _C("_avanzaIteradorPrimeraColumna();");
      this->_avanzaIteradorNormal();
      if ( !this->_hayPosiblesNormal() )
      {
        _C("No hay posibles en este color " << this->_colorAbajoActual);
        listaDisponibles l;
        while(true)
        {
          this->_colorDerechaActual++;
           l = _v[this->_colorDerechaActual][this->_colorAbajoActual];
          if ((l.lista.size() - l.principio) > 0)
          {
            _C("Encontrado color disponible: derecha:" << this->_colorDerechaActual << ", abajo: " << this->_colorAbajoActual);
            break;
          }
        }
        this->_v_res = &(l.lista);
        this->_indice = l.principio;
      }
    }
    inline void _avanzaIteradorPrimeraFila()
    {
      _C("_avanzaIteradorPrimeraFila();");
      this->_avanzaIteradorNormal();
      if ( !this->_hayPosiblesNormal() )
      {
        _C("No hay posibles en este color " << this->_colorAbajoActual);
        listaDisponibles l;
        while(true)
        {
          this->_colorAbajoActual++;
           l = _v[this->_colorDerechaActual][this->_colorAbajoActual];
          if ((l.lista.size() - l.principio) > 0)
          {
            _C("Encontrado color disponible: derecha:" << this->_colorDerechaActual << ", abajo: " << this->_colorAbajoActual);
            break;
          }
        }
        this->_v_res = &(l.lista);
        this->_indice = l.principio;
      }
    }
    inline bool _hayPosiblesNormal() 
    {
      _C("Verificando hayPosiblesNormal. indice: "<< this->_indice <<", this->_v_res->size=" << this->_v_res->size());
      DEBUG_BOOL(this->_indice < this->_v_res->size());
      return (this->_indice < this->_v_res->size());
    }
    inline bool _hayPosiblesPrimeraColumna() 
    {
      if (this->_hayPosiblesNormal())
      {
        return true;
      }
      _C("hayPosiblesPrimeraColumna: Debe cambiar de color");
      DEBUG_INT(this->_colorDerechaActual);
      for(uint32_t i = this->_colorDerechaActual+1;i<this->_v.size();i++)
      {
        listaDisponibles l = _v[i][this->_colorAbajoActual];
        if ((l.lista.size() - l.principio) > 0)
        {
          return true;
        }
      }
      return false;
    }
    inline bool _hayPosiblesPrimeraFila() 
    {
      if (this->_hayPosiblesNormal())
      {
        return true;
      }
      _C("HayPosiblesPrimeraFila: Debe cambiar de color");
      DEBUG_INT(this->_colorAbajoActual);
      for(uint32_t i = this->_colorAbajoActual+1;i<this->_v.size();i++)
      {
        listaDisponibles l = _v[this->_colorDerechaActual][i];
        if ((l.lista.size() - l.principio) > 0)
        {
          return true;
        }
      }
      return false;
    }
    inline bool _hayPosiblesPrimerCasillero() 
    {
      if (this->_hayPosiblesNormal())
      {
        return true;
      }
      for(uint32_t i = this->_colorAbajoActual; i<this->_v.size(); i++)
      {
        for(uint32_t j = this->_colorDerechaActual+1; j<this->_v.size(); j++)
        {
          listaDisponibles l = _v[j][i];
          if ((l.lista.size() - l.principio) > 0)
          {
            return true;
          }
        }
      }
      return false;
    }
    Iterador( IndiceDeColores& p_ic, uint32_t p_i, uint32_t p_a ) : 
      _ic(p_ic),
      _v(p_ic.v),
      _primeraColumna(p_i==TestCaseEj3::PIEZA_VACIA),
      _primeraFila(p_a==TestCaseEj3::PIEZA_VACIA),
      _piezaTransparenteUtilizada(false)
      {
        // Si es primera columna pero no primera fila
        if(this->_primeraColumna && !this->_primeraFila)
        {
          _C("IC::IT() El casillero es primera columna pero no es primera fila");
          this->_avanza = &Iterador::_avanzaIteradorPrimeraColumna;
          this->_hayPosibles = &Iterador::_hayPosiblesPrimeraColumna;
          this->_colorDerechaActual = 0;
          this->_colorAbajoActual = _ic.colorAbajo(p_a);
        }
        // Si es primera fila pero no primera columna
        if(this->_primeraFila && !this->_primeraColumna)
        {
          _C("IC::IT() El casillero es primera fila pero no es primera columna");
          this->_avanza = &Iterador::_avanzaIteradorPrimeraFila;
          this->_hayPosibles = &Iterador::_hayPosiblesPrimeraFila;
          this->_colorDerechaActual = _ic.colorDerecha(p_i); 
          this->_colorAbajoActual = 0;
        }
        // Si no es ni primera columna ni primera fila
        if(!this->_primeraFila && !this->_primeraColumna)
        {
          _C("IC::IT() El casillero no es primera columna ni primera fila");
          this->_avanza = &Iterador::_avanzaIteradorNormal;
          this->_hayPosibles = &Iterador::_hayPosiblesNormal;
          this->_colorDerechaActual = _ic.colorDerecha(p_i); 
          this->_colorAbajoActual = _ic.colorAbajo(p_a);
        }
        // Si es el primer casillero (1ra columna y 1ra fila a la vez)
        if(this->_primeraColumna && this->_primeraFila)
        {
          _C("IC::IT() El casillero es primera columna y primera fila (1er casillero)");
          this->_avanza = &Iterador::_avanzaIteradorPrimerCasillero;
          this->_hayPosibles = &Iterador::_hayPosiblesPrimerCasillero;
          this->_quitarPieza = &IndiceDeColores::_quitarPieza;
          this->_colorDerechaActual = 0; 
          this->_colorAbajoActual = 0;
          //this->_indice = 1;
        }
        else
        {
          this->_quitarPieza = &IndiceDeColores::_quitarPieza;
        }
        this->_v_res = &(this->_v[_colorDerechaActual][_colorAbajoActual].lista);
        this->_indice = this->_v[this->_colorDerechaActual][this->_colorAbajoActual].principio;
        _C("IC::IT() colorDerechaActual= "<< this->_colorDerechaActual <<", colorAbajoActual= " << this->_colorAbajoActual << ", indice= " << this->_indice);
        if(this->_v_res->size() == 0)
        {
          _C("IC::IT(); avanzando hasta colorDerechaActual= "<< this->_colorDerechaActual <<", colorAbajoActual= " << this->_colorAbajoActual << ", indice= " << this->_indice);
          (this->*_avanza)();
        }
      }
    /**
     * Describe si hay piezas disponibles en el iterador
     */
    bool hayPiezasPosibles( void )
    {
      if ((this->*_hayPosibles)())
      {
        _C("hayPosibles = true");
        return true;
      }
      _C("hayPosibles = false, utilizando PIEZA TRANSPARENTE");
      return !this->_piezaTransparenteUtilizada;
    }
    /**
     * Avanza el iterador.
     * El usuario debe revisar si hayPiezasPosibles() primero.
     */
    inline Iterador& operator++( int )
    {
      if (!((this->*_hayPosibles)())){
        _C("Avanzando el iterador. Ya no quedan piezas. (pieza transparente).");
        this->_piezaTransparenteUtilizada = true;
        return *this;
      }
      _C("Avanzando el iterador normalmente");
      (this->*_avanza)();
      return *this;
    }
    /**
     * Devuelve el contenido del iterador
     */
    inline uint32_t operator*( void ) 
    {
      if (!((this->*_hayPosibles)()))
      {
        return TestCaseEj3::PIEZA_VACIA;
      }
      DEBUG_INT(this->_indice);
      DEBUG_INT((*this->_v_res).size());
      return (*this->_v_res)[this->_indice].indiceEnListaDePiezas;

    }
  };
  IndiceDeColores( uint32_t p_cantidadDeColores, vector<TestCaseEj3::Pieza> &p_listaDePiezas ) 
  : listaDePiezas(p_listaDePiezas), v(p_cantidadDeColores, vector<listaDisponibles>(3, listaDisponibles()) ){
    //this->_v_pieza_indexada.push_back(IndiceDeColores::piezaIndexada(0,0));
    // Agrego las piezas al indice de piezas por color, me salteo pieza vacia
    for (uint32_t i = 1; i<this->listaDePiezas.size(); i++){
      TestCaseEj3::Pieza pieza = this->listaDePiezas[i];
      uint32_t colorDerecha = this->colorDerecha(i);
      uint32_t colorAbajo = this->colorAbajo(i);
      v[colorDerecha][colorAbajo].lista.push_back(IndiceDeColores::piezaIndexada(i,v[colorDerecha][colorAbajo].lista.size()));
      //this->_v_pieza_indexada.push_back(IndiceDeColores::piezaIndexada(i,v[colorDerecha][colorAbajo].lista.size()));
    }
   
  };
  
    /**
     * Dado un ID de pieza, lo quita del indice
     */
    void _quitarPieza ( Iterador &it )
    {
      uint32_t colorDerecha = this->colorDerecha(*it);// listaDePiezas[*it].colorDerecha;
      uint32_t colorAbajo = this->colorAbajo(*it);// listaDePiezas[*it].colorAbajo;
      listaDisponibles& listaDisp = v[colorDerecha][colorAbajo];
      DEBUG_INT(it._indice);
      DEBUG_INT((*it._v_res)[it._indice].indiceEnListaDisponibles);
      DEBUG_INT(listaDisp.principio);
      // Me aseguro que el elemento que quiero "borrar" quede al principio
      if ( (*it._v_res)[it._indice].indiceEnListaDisponibles != listaDisp.principio )
      {
        // Si no esta al principio, swapeo
        uint32_t bak = listaDisp.lista[it._indice].indiceEnListaDePiezas;
        listaDisp.lista[it._indice].indiceEnListaDePiezas = listaDisp.lista[listaDisp.principio].indiceEnListaDePiezas;
        listaDisp.lista[listaDisp.principio].indiceEnListaDePiezas = bak;
      }
      // Aumento el "principio" de la lista
      (listaDisp.principio)++;
    }

    void restaurarPieza ( IndiceDeColores::Iterador& it )
    {
      uint32_t colorDerecha = this->colorDerecha(*it);// listaDePiezas[*it].colorDerecha;
      uint32_t colorAbajo = this->colorAbajo(*it);// listaDePiezas[*it].colorAbajo;
      listaDisponibles& listaDisp = v[colorDerecha][colorAbajo];
      // Disminuyo el "principio" de la lista
      (listaDisp.principio)--; 
      // Si no estaba al principio, restauro el elemento a su posicion original
      if (it._indice != listaDisp.principio)
      {
        uint32_t bak = listaDisp.lista[it._indice].indiceEnListaDePiezas;
        listaDisp.lista[it._indice] = listaDisp.lista[listaDisp.principio];
        listaDisp.lista[listaDisp.principio].indiceEnListaDePiezas = bak;
      }
    }
  /**
   * Dadas las piezas de la izquierda y de arriba devuelve una lista 
   * con los ID de las posibles piezas que se pueden agregar
   */
  Iterador &damePiezasPosibles( uint32_t piezaIzquierda, uint32_t piezaArriba)
  {
    if(piezaIzquierda != TestCaseEj3::PIEZA_VACIA && piezaArriba != TestCaseEj3::PIEZA_VACIA){ _C("IC::IT damePiezasPosibles("<< piezaIzquierda <<","<< piezaArriba <<") -> con piezas no nulas");}
    if(piezaIzquierda == TestCaseEj3::PIEZA_VACIA && piezaArriba != TestCaseEj3::PIEZA_VACIA){ _C("IC::IT damePiezasPosibles("<< piezaIzquierda <<","<< piezaArriba <<") -> con pieza izquierda nula");}
    if(piezaIzquierda != TestCaseEj3::PIEZA_VACIA && piezaArriba == TestCaseEj3::PIEZA_VACIA){ _C("IC::IT damePiezasPosibles("<< piezaIzquierda <<","<< piezaArriba <<") -> con pieza arriba nula");}
    if(piezaIzquierda == TestCaseEj3::PIEZA_VACIA && piezaArriba == TestCaseEj3::PIEZA_VACIA){ _C("IC::IT damePiezasPosibles("<< piezaIzquierda <<","<< piezaArriba <<") -> con ambas piezas nulas");}
    Iterador *it = new Iterador( *this, piezaIzquierda, piezaArriba );
    return *it;
  }

private:
  
};

#endif

\end{lstlisting}
\clearpage

\lstset{caption={IteradorIndiceDePiezas.h},label=ej3}
\begin{lstlisting}

#include "IndiceDePiezas.h"
class IteradorIndiceDePiezas
{
private:
  bool _piezaTransparenteUtilizada;
  bool _utilizarPiezaTransparente;
protected:
  vector<bool>& _indicePiezasDisponibles;
  vector<uint32_t>& _indiceSecuencial;
  vector<uint32_t>* _indiceColores;
  IndiceDePiezas::listaDePiezas* _v;
  IndiceDePiezas::listaDePiezas::iterator _v_it;
  //IteradorIndiceDePiezas ( IteradorIndiceDePiezas::*avanzar )( int );
  IndiceDePiezas& _ip;
  uint32_t _posicion;
public:
  IteradorIndiceDePiezas( IndiceDePiezas&, uint32_t );
  virtual ~IteradorIndiceDePiezas() = 0;
  virtual bool hayPiezasPosibles() = 0;
  virtual IteradorIndiceDePiezas& operator++( int );
  virtual uint32_t operator*();
  void utilizarPiezaTransparente();
};

#include "IteradorSecuencial.h"
#include "IteradorColores.h"
#endif

\end{lstlisting}
\clearpage

\lstset{caption={IteradorIndiceDePiezas.cpp},label=ej3}
\begin{lstlisting}

#include "IteradorIndiceDePiezas.h"

IteradorIndiceDePiezas::IteradorIndiceDePiezas( IndiceDePiezas& ip, uint32_t posicion )
  : _indicePiezasDisponibles( ip._indicePiezasDisponibles ),
    _indiceSecuencial ( ip._indiceSecuencial.top() ),

    _ip( ip ),
    _posicion( posicion )
{
  uint32_t piezaIzquierda = ip._t.dameLaPiezaDeIzquierdaDePosicion( posicion );
  uint32_t piezaArriba = ip._t.dameLaPiezaDeArribaDePosicion( posicion );
  if(piezaIzquierda!=TestCaseEj3::PIEZA_VACIA && piezaArriba !=TestCaseEj3::PIEZA_VACIA)
  {

    this->_indiceColores = &(ip._indiceDeDosColores
      [ip._listaDePiezas[piezaIzquierda].colorDerecha]
      [ip._listaDePiezas[piezaArriba].colorAbajo]
      .top());
  }
  this->_piezaTransparenteUtilizada = false;
  this->_utilizarPiezaTransparente = false;
  _C("Inicializado IteradorIndiceDePiezas");
}


bool IteradorIndiceDePiezas::hayPiezasPosibles()
{
  return !_piezaTransparenteUtilizada;
}
IteradorIndiceDePiezas& IteradorIndiceDePiezas::operator++( int )
{
  _C( "IteradorIndiceDePiezas::operator++" );
  this->_utilizarPiezaTransparente = true;
  return *this;
}
uint32_t IteradorIndiceDePiezas::operator*()
{
  if ( this->_utilizarPiezaTransparente )
  {
    _C( "Utilizando pieza transparente" );
    return TestCaseEj3::PIEZA_VACIA;
  }
  else
  {
    return *( this->_v_it );
  }
}
void IteradorIndiceDePiezas::utilizarPiezaTransparente()
{
  this->_piezaTransparenteUtilizada = true;
}

\end{lstlisting}
\clearpage

% -----------------------------------------------
\end{document}
